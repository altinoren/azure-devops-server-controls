import * as  Q from "q";

import { DateSKParser } from "Analytics/Scripts/DateSKParser";

import { KanbanTimeType, ScatterPlotCustomDataWorkItem } from "Widgets/Scripts/KanbanTime/KanbanTimeContracts";

import * as CultureUtils from "VSS/Utils/Culture";
import * as StringUtils from "VSS/Utils/String";
import * as DateUtils from "VSS/Utils/Date";

import { ClientConstants } from "Dashboards/Scripts/Common";
import { WidgetOptions, WidgetLightboxOptions } from "Dashboards/Scripts/Contracts";

import * as WidgetContracts from "TFS/Dashboards/WidgetContracts";
import { SemanticVersion } from "TFS/Dashboards/Contracts";
import { WidgetStatusHelper, WidgetEvent, WidgetSizeConverter } from "TFS/Dashboards/WidgetHelpers";
import { WidgetDomClassNames } from "Dashboards/Scripts/Generated/Constants";

import {TfsContext, IRouteData } from "Presentation/Scripts/TFS/TFS.Host.TfsContext";

import * as Controls from "VSS/Controls";
import * as SDK from "VSS/SDK/Shim";
import { Cancelable } from "VSS/Utils/Core";
import { KanbanTimeControl, KanbanTimeControlOptions } from "Widgets/Scripts/Shared/KanbanTimeControl";
import { BaseWidgetControl } from "Widgets/Scripts/VSS.Control.BaseWidget";
import { WorkItemTypeFilterMode } from "Widgets/Scripts/Shared/WorkItemTypePicker";
import { WidgetSize } from "TFS/Dashboards/Contracts";
import { RadioSettingsFieldPickerSettings } from "Widgets/Scripts/Shared/RadioSettingsFieldPicker";
import { KanbanTimeWidgetOptions, KanbanTimeSettings, TimePeriodFieldIdentifiers, WitSelectorIdentifierValues_V1_0_0 } from "Widgets/Scripts/KanbanTimeContracts";
import * as WidgetResources from "Widgets/Scripts/Resources/TFS.Resources.Widgets";
import * as TimeZoneUtils from "Widgets/Scripts/Shared/TimeZoneUtilities";
import { AnalyticsChartingClient } from "Widgets/Scripts/DataServices/Legacy/AnalyticsChartingClient";
import * as WITDialogShim from "WorkItemTracking/SharedScripts/WorkItemDialogShim";
import { WidgetTelemetry } from "Widgets/Scripts/VSS.Widget.Telemetry";
import WITConstants = require("Presentation/Scripts/TFS/Generated/TFS.WorkItemTracking.Constants");
import Events_Action = require("VSS/Events/Action");
import { AnalyticsActionControl } from "Widgets/Scripts/Shared/ControlUtilities";
import { WidgetLinkHelper } from "Widgets/Scripts/WidgetLinkHelper";

import { AnalyticsExceptionType, AnalyticsExceptionParsing, ErrorParser } from "Analytics/Scripts/AnalyticsExceptionUtilities";

/**
 * Rendering options the widget uses to draw the chart.
 */
interface RenderOptions {
    widgetSettings: WidgetContracts.WidgetSettings;
    animateChart: boolean;
    isLightbox: boolean;

    /** Defines the size within which to render the widget. Uses widgetSettings.size if no size is provided here. */
    widgetRenderAreaSizeInPx?: WidgetContracts.Size;

    /** Used to check if the requested render has been canceled before taking actions to update the widget rendering. */
    cancelable: Cancelable;
}

/**
 * A widget visualizing the Lead Time or Cycle Time for a set of teams for a given backlog category or list of work item types.
 */
export class KanbanTime extends BaseWidgetControl<KanbanTimeWidgetOptions> implements WidgetContracts.IWidget {

    /**
     * The current version of widget settings generated by the config.
     */
    public static readonly latestSettingsVersion: SemanticVersion = {
        major: 2,
        minor: 0,
        patch: 0
    };

    /**
     * Space allocation reserved for the header that cannot be used by the chart.
     * 22 for title, 16 for subheader, 10 for widget top margin, 10 for header bottom padding.
     */
    public static readonly controlHostHeightAdjustment: number = 58;

    /**
     * Extra space while during lightbox view
     * It is 10px each that we removed from the top and bottom padding we are adding back to the height
     */
    public static readonly controlLightBoxHeightAdjustment: number = 20;

    /**
     * While the Analytics service is likely capable of handling a larger number, this value was chosen to have parity with the
     * existing backlogs to limit sending large values that would not only take more time to retrieve
     * a result but would not be presented well because of the data density.
     */
    public static readonly maxAllowedTimePeriodDays: number = 180;

    /**
     * The default number of days the widget should be configured to look back.
     */
    public static readonly defaultTimePeriodDays: number = 30;

    private kanbanTimeControl: KanbanTimeControl;
    private $title: JQuery;
    private $subtitle: JQuery;
    private $controlContainer: JQuery;

    private title: string;
    private subtitle: string;
    private latestRenderCancelable: Cancelable; // The latest cancelable passed to a call to render

    private analyticsChartingClient: AnalyticsChartingClient;

    private previousSettings: WidgetContracts.WidgetSettings;
    private isReady: boolean;

    public initializeOptions(options?: KanbanTimeWidgetOptions) {
        let cssClass = (options.timeType === KanbanTimeType.Lead) ? "lead-time" : "cycle-time";

        super.initializeOptions($.extend(
            {
                coreCssClass: cssClass
            },
            options));

        this.isReady = true;
        this.analyticsChartingClient = options.analyticsClient;
    }

    /**
    * Widget Author implements this method if they want to override the visibility of the widget menu based on conditions
    * identified while initializing/loading the widget.
    */
    public canShowWidgetMenu(): IPromise<boolean> {
        return Q.resolve(this.isReady);
    }

    public preload(settings: WidgetContracts.WidgetSettings): IPromise<WidgetContracts.WidgetStatus> {
        KanbanTime.convertWidgetSettingsToNewestVersion(settings);
        KanbanTime.restrictStartDateToMaxAllowedDays(settings);
        this.prepareWidgetStructure();
        return WidgetStatusHelper.Success();
    }

    public load(settings: WidgetContracts.WidgetSettings): IPromise<WidgetContracts.WidgetStatus> {
        let cancelable = new Cancelable(this);
        this.latestRenderCancelable = cancelable;

        let renderOptions: RenderOptions = {
            widgetSettings: settings,
            animateChart: true,
            isLightbox: false,
            cancelable: cancelable,
        };
        return this.render(renderOptions);
    }

    public reload(settings: WidgetContracts.WidgetSettings): IPromise<WidgetContracts.WidgetStatus> {
        // Cancel the previous render
        this.latestRenderCancelable.cancel();

        let cancelable = new Cancelable(this);
        this.latestRenderCancelable = cancelable;

        let renderOptions: RenderOptions = {
            widgetSettings: settings,
            animateChart: false,
            isLightbox: false,
            cancelable: cancelable,
        };
        return this.render(renderOptions);
    }

    public lightbox(settings: WidgetContracts.WidgetSettings, lightboxSize: WidgetContracts.Size): IPromise<WidgetContracts.WidgetStatus> {
        let cancelable = new Cancelable(this);
        this.latestRenderCancelable = cancelable;

        let renderOptions: RenderOptions = {
            widgetSettings: settings,
            animateChart: true,
            isLightbox: true,
            widgetRenderAreaSizeInPx: lightboxSize,
            cancelable: cancelable,
        };

        return this.preload(settings)
            .then(() => {
                return this.render(renderOptions);
            });
    }

    public listen(event: string, args: any): void {
        if (event === WidgetEvent.LightboxResized) {
            let lightboxSize = (<WidgetContracts.EventArgs<WidgetContracts.Size>>args).data;
            this.kanbanTimeControl.resize(
                lightboxSize.height + KanbanTime.controlLightBoxHeightAdjustment,
                lightboxSize.width);
        } else if (event === WidgetEvent.LightboxOptions) {
            // This information is retrieved from the rendered widget on the dashboard.
            // Because we don't show the lightbox button unless the widget finished loading successfully,
            // we are guaranteed to have set this.title and this.subtitle by the time this is called.
            let callback = args.data;
            let lightboxOptions = <WidgetLightboxOptions>{};
            lightboxOptions.title = this.title;
            lightboxOptions.subtitle = this.subtitle;
            callback(lightboxOptions);
        }
    }

    /**
     * Test settings to see if query parameters or chart size changed
     */
    private queryChanged(settings: WidgetContracts.WidgetSettings): boolean {
        return !this.previousSettings
            || settings.size.columnSpan !== this.previousSettings.size.columnSpan || settings.size.rowSpan !== this.previousSettings.size.rowSpan
            || settings.customSettings !== this.previousSettings.customSettings;
    }

    private render(options: RenderOptions): IPromise<WidgetContracts.WidgetStatus> {
        let renderPromise: IPromise<void> = Q<void>(null);
        if (!KanbanTime.isConfigured(options.widgetSettings)) {
            renderPromise = this.mergeDefaultSettings(options.widgetSettings);
        }

        return renderPromise
            .then(() => {
                this.updateHeader(options.widgetSettings);

                if (this.queryChanged(options.widgetSettings)) {
                    this.$controlContainer.empty();

                    let controlOptions = this.convertRenderOptionsToControlOptions(options);
                    this.kanbanTimeControl = KanbanTimeControl.create(
                        KanbanTimeControl,
                        this.$controlContainer,
                        controlOptions);

                    return this.kanbanTimeControl.render(options.animateChart).then(()=>{
                        let chartSettings = KanbanTime.parseCustomSettings(options.widgetSettings.customSettings.data);
                        this.publishLoadedEvent({
                            "Width": controlOptions.width,
                            "Height": controlOptions.height,

                            "TimePeriodIdentifier": chartSettings.dataSettings.timePeriod.identifier,
                            "TimePeriodValue": chartSettings.dataSettings.timePeriod.settings,

                            "WorkItemSelectorIdentifier": chartSettings.dataSettings.witSelector.identifier,
                            "WorkItemSelectorValue": chartSettings.dataSettings.witSelector.settings
                        });
                    });
                }
                //store passed settings for next comparison
                this.previousSettings = options.widgetSettings;
            })
            .then<WidgetContracts.WidgetStatus>(() => WidgetStatusHelper.Success as any,
            e => {
                if (AnalyticsExceptionParsing.recognizeAnalyticsException(e) === AnalyticsExceptionType.DataNotReady) {
                    this.isReady = false;
                    AnalyticsActionControl.createNotReadyActionControl(
                        this.getElement(),
                        options.widgetSettings);
                    return WidgetStatusHelper.Success() as any;
                }
                else {
                    return WidgetStatusHelper.Failure(ErrorParser.stringifyODataError(e), true);
                }
            });
    }

    private static parseCustomSettings(stringifiedSettings: string): KanbanTimeSettings {
        return JSON.parse(stringifiedSettings);
    }

    private mergeDefaultSettings(widgetSettings: WidgetContracts.WidgetSettings): IPromise<void> {
        if (this.analyticsChartingClient == null) {
            let command = this._options.timeType === KanbanTimeType.Lead ? "LeadTime" : "CycleTime";
            this.analyticsChartingClient = new AnalyticsChartingClient(command);
        }

        let project = this.webContext.project.id; // Default is the current project
        let teamIds = [this.teamContext.id]; // Default is the current team

        return this.analyticsChartingClient.getBacklogs(project, teamIds)
            .then<void>(backlogs => {
                // getBacklogs returns visible backlogs ordered by level so we take
                // the first backlog in the array.
                let lowestLevelVisibleBacklog = backlogs[0];

                if (lowestLevelVisibleBacklog) {
                    let customSettings: KanbanTimeSettings = {
                        dataSettings: {
                            project: project,
                            teamIds: teamIds,
                            timePeriod: {
                                identifier: TimePeriodFieldIdentifiers.RollingPeriod,
                                settings: KanbanTime.defaultTimePeriodDays
                            },
                            witSelector: {
                                identifier: WorkItemTypeFilterMode[WorkItemTypeFilterMode.BacklogCategory],
                                settings: lowestLevelVisibleBacklog.Category
                            }
                        }
                    };

                    let teamName = this.teamContext.name;

                    widgetSettings.name = this._options.timeType === KanbanTimeType.Lead
                        ? StringUtils.format(WidgetResources.LeadTime_TitleFormat, teamName)
                        : StringUtils.format(WidgetResources.CycleTime_TitleFormat, teamName);
                    widgetSettings.customSettings.data = JSON.stringify(customSettings);
                }
                else {
                    throw WidgetResources.KanbanTime_DefaultSettings_FailedToFindAnyBacklogsError;
                }
            });
    }

    private convertRenderOptionsToControlOptions(options: RenderOptions): KanbanTimeControlOptions {
        let size = options.widgetRenderAreaSizeInPx || KanbanTime.getWidgetSizeInPx(options.widgetSettings.size);
        let userHasClickPermission: boolean = WidgetLinkHelper.canUserAccessWITQueriesPage ();
        // The height adjustment differs depending on if the widget was rendered in a lightbox
        // because in a lightbox the title/subtitle are hidden.
        if (!options.isLightbox) {
            size.height -= KanbanTime.controlHostHeightAdjustment;
        } else {
            size.height += KanbanTime.controlLightBoxHeightAdjustment;
        }

        let customSettings = KanbanTime.parseCustomSettings(options.widgetSettings.customSettings.data);
        let dataSettings = customSettings.dataSettings;

        // Get start date
        let startDateString: string;
        if (dataSettings.timePeriod.identifier === TimePeriodFieldIdentifiers.RollingPeriod) {
            let endDate = TimeZoneUtils.getTodayInAccountTimeZone();
            let startDate = DateUtils.addDays(endDate, -dataSettings.timePeriod.settings, true /* adjustDSTOffset */);
            startDateString = DateUtils.format(startDate, DateSKParser.dateStringFormat);
        } else if (dataSettings.timePeriod.identifier === TimePeriodFieldIdentifiers.StartDate) {
            startDateString = dataSettings.timePeriod.settings as string;
        }

        let timeControlOptions: KanbanTimeControlOptions = {
            teamIds: dataSettings.teamIds,
            startDate: startDateString,
            height: size.height,
            width: size.width,
            timeType: this._options.timeType,
            timeoutMs: ClientConstants.WidgetAjaxTimeoutMs,
            hideFilterControlUntilWidth: KanbanTime.getWidgetSizeInPx(<WidgetSize>{columnSpan: 2, rowSpan: 1}).width,
        };

        if (userHasClickPermission) {
           timeControlOptions.onClick = (workItems) => { this.showTooltipSelection(workItems); };
        }

        // Set selected work item types option
        let witSelectorIdentifier = dataSettings.witSelector.identifier;
        let witSelectorValue = dataSettings.witSelector.settings;
        if (witSelectorIdentifier === WorkItemTypeFilterMode[WorkItemTypeFilterMode.WorkItemType]) {
            timeControlOptions.workItemTypes = [witSelectorValue];
        } else if (witSelectorIdentifier === WorkItemTypeFilterMode[WorkItemTypeFilterMode.BacklogCategory]) {
            timeControlOptions.backlogCategory = witSelectorValue;
        }

        return timeControlOptions;
    }

    /**
     * Converts widget size dimensions into pixels
     * @param widgetSize - The size of the widget in span units
     */
    private static getWidgetSizeInPx(widgetSize: WidgetSize): WidgetContracts.Size {
        return {
            height: WidgetSizeConverter.RowsToPixelHeight(widgetSize.rowSpan),
            width: WidgetSizeConverter.ColumnsToPixelWidth(widgetSize.columnSpan),
        };
    }

    /**
     * Modifies older widget settings to update them to the newest version.
     */
    public static convertWidgetSettingsToNewestVersion(settings: WidgetContracts.WidgetSettings): void {
        if (KanbanTime.isConfigured(settings) && settings.customSettings.version.major === 1) {
            let customSettings = KanbanTime.parseCustomSettings(settings.customSettings.data);

            // Update witSelector identifiers
            let currentWitSelectorIdentifier = customSettings.dataSettings.witSelector.identifier;
            switch (currentWitSelectorIdentifier) {
                case WitSelectorIdentifierValues_V1_0_0.Backlog:
                    customSettings.dataSettings.witSelector.identifier = WorkItemTypeFilterMode[WorkItemTypeFilterMode.BacklogCategory];
                    break;
                case WitSelectorIdentifierValues_V1_0_0.WitType:
                    customSettings.dataSettings.witSelector.identifier = WorkItemTypeFilterMode[WorkItemTypeFilterMode.WorkItemType];
                    break;
            }

            settings.customSettings.data = JSON.stringify(customSettings);
            settings.customSettings.version = KanbanTime.latestSettingsVersion;
        }
    }

    /**
     * Modifies settings if necessary restricting a time period to not exceed max days.
     * This occurs when a start date is configured rather than a rolling period and enough
     * days have passed that the start date is over 180 days in the past from today.
     * @param settings to check and update.
     */
    private static restrictStartDateToMaxAllowedDays(settings: WidgetContracts.WidgetSettings): void {
        if (KanbanTime.isConfigured(settings)) {
            var customSettings = KanbanTime.parseCustomSettings(settings.customSettings.data);

            // Restrict time period to max days allowed
            if (customSettings.dataSettings.timePeriod.identifier === TimePeriodFieldIdentifiers.StartDate) {
                var earliestAllowedStartDate = DateUtils.addDays(TimeZoneUtils.getTodayInAccountTimeZone(), -KanbanTime.maxAllowedTimePeriodDays);
                var configuredStartDate = DateUtils.parseDateString(<string>customSettings.dataSettings.timePeriod.settings, DateSKParser.dateStringFormat);
                // If configured date is earlier than earliest allowed, update settings
                if (DateUtils.defaultComparer(configuredStartDate, earliestAllowedStartDate) < 0) {
                    customSettings.dataSettings.timePeriod.settings = DateUtils.format(earliestAllowedStartDate, DateSKParser.dateStringFormat);
                    settings.customSettings.data = JSON.stringify(customSettings);
                }
            } else if (customSettings.dataSettings.timePeriod.settings > KanbanTime.maxAllowedTimePeriodDays) {
                // Don't exceed allowed rolling period
                customSettings.dataSettings.timePeriod.settings = KanbanTime.maxAllowedTimePeriodDays
                settings.customSettings.data = JSON.stringify(customSettings);
            }
        }
    }

    private static isConfigured(settings: WidgetContracts.WidgetSettings): boolean {
        return settings.customSettings.data != null;
    }

    private prepareWidgetStructure(): void {
        // Header
        this.$title = $("<div>").addClass("inner-title");

        this.$subtitle = $("<div>")
            .addClass(WidgetDomClassNames.SubTitle);

        let $header = $("<h2>")
            .addClass(WidgetDomClassNames.Title)
            .append(this.$title)
            .append(this.$subtitle);

        // Chart container
        this.$controlContainer = $("<div>").addClass("control-instance");

        // Add to widget
        this.getElement()
            .addClass(WidgetDomClassNames.WidgetContainer)
            .append($header)
            .append(this.$controlContainer);
    }

    /**
     * Updates the rendered title and subtitle of the widget
     * @param settings - The widget settings
     */
    private updateHeader(settings: WidgetContracts.WidgetSettings): void {
        this.updateTitle(settings.name);

        let chartSettings = KanbanTime.parseCustomSettings(settings.customSettings.data);
        this.updateSubtitle(chartSettings.dataSettings.timePeriod);
    }

    private updateTitle(newTitle: string): void {
        this.$title.text(newTitle);
        this.title = newTitle;
        this.addTooltipIfOverflow(this.$title);
    }

    private updateSubtitle(timePeriod: RadioSettingsFieldPickerSettings<number | string>): void {
        let subtitle;
        let cultureDateTimeFormat = CultureUtils.getDateTimeFormat();

        if (timePeriod.identifier === TimePeriodFieldIdentifiers.RollingPeriod) {
            subtitle = (timePeriod.settings === 1)
                ? WidgetResources.TimePeriodSubtitleFormat_Singular
                : StringUtils.format(WidgetResources.TimePeriodSubtitleFormat_Plural, timePeriod.settings);
        } else {
            let date = DateSKParser.parseDateStringAsLocalTimeZoneDate(<string>timePeriod.settings);
            let dateString = cultureDateTimeFormat.ShortDatePattern !== null
                ? DateUtils.format(date, cultureDateTimeFormat.ShortDatePattern)
                : date.toLocaleDateString();
            subtitle = StringUtils.format(WidgetResources.TimePeriodSubtitleFormat_StartDate, dateString);
        }

        this.$subtitle.text(subtitle);
        this.subtitle = subtitle;
    }

    private showTooltipSelection(workItemData: ScatterPlotCustomDataWorkItem[]): void {
        let descriptionType: string;
        let clickTarget: string;
        if (workItemData.length > 1) {
            descriptionType = "SummaryField";
            let workItemList = workItemData.map(w => w.workItemType);
            let uniqueList = workItemList.filter((x, i, a) => a.indexOf(x) == i);
            clickTarget = uniqueList.join(",");
            let workItemIds = workItemData.map(w => w.id);
            this.navigateToSelection(workItemIds);
        } else if (workItemData.length === 1) {
            WITDialogShim.showWorkItemById(Number(workItemData[0].id));
            descriptionType = "WorkItem";
            clickTarget = workItemData[0].workItemType;
        }
        // Fire the telemetry event
        WidgetTelemetry.onWidgetClick(this._options.typeId, descriptionType, {
            "ClickTarget": clickTarget
        });
    };

    private navigateToSelection(workItemIds: string[]): void {
        let wiql = `SELECT [${WITConstants.CoreFieldRefNames.Id}],[${WITConstants.CoreFieldRefNames.WorkItemType}],[${WITConstants.CoreFieldRefNames.Title}] ` +
            `FROM WorkItems WHERE [${WITConstants.CoreFieldRefNames.Id}] IN ({0})`;
        wiql = StringUtils.format(wiql, workItemIds.join(","));
        let tempQueryName = this._options.timeType == KanbanTimeType.Lead
            ? WidgetResources.KanbanTime_LeadTime_TempQuery
            : WidgetResources.KanbanTime_CycleTime_TempQuery;
        let queryURLFragment = TfsContext.getDefault().getActionUrl("", "queries", {
            _a: "query",
            wiql: wiql,
            name: tempQueryName
        } as IRouteData);
        Events_Action.getService().performAction(Events_Action.CommonActions.ACTION_WINDOW_OPEN, {
            url: queryURLFragment
        });
    }
}

SDK.VSS.register("dashboards.LeadTime", () => KanbanTime);
SDK.registerContent("dashboards.leadTime-init", (context: SDK.InternalContentContextData) => {
    let options: KanbanTimeWidgetOptions = context.options;
    options.timeType = KanbanTimeType.Lead;
    return Controls.create(KanbanTime, context.$container, options);
});

SDK.VSS.register("dashboards.CycleTime", () => KanbanTime);
SDK.registerContent("dashboards.cycleTime-init", (context: SDK.InternalContentContextData) => {
    let options: KanbanTimeWidgetOptions = context.options;
    options.timeType = KanbanTimeType.Cycle;
    return Controls.create(KanbanTime, context.$container, options);
});
