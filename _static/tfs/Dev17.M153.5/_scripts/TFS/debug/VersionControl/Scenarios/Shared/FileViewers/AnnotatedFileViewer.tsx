import { MessageBar, MessageBarType } from "OfficeFabric/MessageBar";
import { css } from "OfficeFabric/Utilities";
import * as React from "react";
import { format } from "VSS/Utils/String";

import { StatefulSplitter } from "Presentation/Scripts/TFS/Components/StatefulSplitter";
import { BlameList } from "VersionControl/Scenarios/Shared/FileViewers/BlameList";
import { EditableFileViewer, EditableFileViewerProps, FileViewerSelection, FileViewerScrollPosition } from "VersionControl/Scenarios/Shared/FileViewers/EditableFileViewer";
import { AnnotationEngine, AnnotationBlock, VersionMap } from "VersionControl/Scripts/Controls/AnnotateAnnotationEngine";
import { GitAnnotationEngine } from "VersionControl/Scripts/Controls/AnnotateGitAnnotationEngine";
import { TfsAnnotationEngine } from "VersionControl/Scripts/Controls/AnnotateTfsAnnotationEngine";
import { ChangeList, HistoryEntry } from "VersionControl/Scripts/Generated/TFS.VersionControl.Legacy.Contracts";
import { GitRepositoryContext } from "VersionControl/Scripts/GitRepositoryContext";
import { RepositoryType } from "VersionControl/Scripts/RepositoryContext";
import * as VCResources from "VersionControl/Scripts/Resources/TFS.Resources.VersionControl";
import { TfvcRepositoryContext } from "VersionControl/Scripts/TfvcRepositoryContext";
import { areSimilar } from "VersionControl/Scripts/Utils/Number";

import "VSS/LoaderPlugins/Css!VersionControl/Shared/FileViewers/AnnotatedFileViewer";

export interface AnnotatedFileViewerProps extends EditableFileViewerProps {
    isAnnotate: boolean;
    linesCount: number;
    onCommitClick?: React.EventHandler<React.MouseEvent<HTMLLinkElement>>;
    onChangeVersion?(version: string, line: number): void;
}

export interface AnnotatedFileViewerState {
    blocks: AnnotationBlock[];
    /**
     * Message coming from the annotation engine with information about the results.
     */
    warningMessage: string;
    lineHeight: number;
    lineNumber: number;
    /**
     * Last requested vertical scroll position of the File viewer.
     * Once component updates, this property becomes undefined again.
     * This prevents that smooth scrolling feeds back the source control originating this scroll change.
     */
    fileScrollTop: number;
    /**
     * Last requested vertical scroll position of the Blame pane, while it matches.
     */
    blameScrollTop: number;
    /**
     * Top gap before the first line inside the FileViewer scrolling pane.
     * It's generated by Monaco widgets like Find, which adds extra room on top of the first line.
     */
    firstLineTop: number;
    /**
     * Maximum time we wait for FileViewer to match the requested scrollTop.
     * This prevents requestedScrollTop to wrongly silence scroll forever.
     * Although on my tests I've never been able to cause this malfunction.
     */
    requestedScrollTime: number;
}

/**
 * Maximum time we wait for a control to match the requested scrollTop.
 * This prevents requestedScrollTop state to wrongly silence scroll forever.
 * Although on my tests I've never been able to cause this to malfunction.
 */
const requestScrollExpiracyMilliseconds = 600;

/**
 * Component that renders a blame/annotate panel aside to an editable FileViewer.
 */
export class AnnotatedFileViewer extends React.PureComponent<AnnotatedFileViewerProps, AnnotatedFileViewerState> {
    public static defaultProps = {
        isVisible: true,
    } as EditableFileViewerProps;

    public state = {} as AnnotatedFileViewerState;

    private annotationEngine: AnnotationEngine;

    public componentWillMount() {
        this.createAnnotationEngine(this.props);
    }

    public componentWillUnmount() {
        this.destroyEngine();
    }

    public componentWillReceiveProps(nextProps: AnnotatedFileViewerProps) {
        if (nextProps.displayItem !== this.props.displayItem) {
            this.destroyEngine();

            this.setState({
                blocks: undefined,
                fileScrollTop: undefined,
                blameScrollTop: undefined,
                lineNumber: undefined,
                warningMessage: undefined,
            } as AnnotatedFileViewerState);
        } else if (nextProps.linesCount !== this.props.linesCount && this.hasBlocks()) {
            const lastBlock = this.state.blocks[this.state.blocks.length - 1];
            const lastLine = lastBlock.startLine + lastBlock.lineCount;
            if (lastLine <= nextProps.linesCount) {
                this.setState({
                    blocks: [...this.state.blocks, createFinalGap(lastLine, nextProps.linesCount)],
                } as AnnotatedFileViewerState);
            }
        }

        this.createAnnotationEngine(nextProps);
    }

    public render(): JSX.Element {
        const isFixedPaneVisible = Boolean(this.props.isAnnotate && this.state.lineHeight);
        const className = css(
            "vc-new-annotated-file-viewer",
            !this.props.isVisible && "file-viewer-hidden");

        // TODO This MessageBar should use NotificationArea, once we promote AnnotationEngine to Flux
        return <div className={className}>
            {
                this.state.warningMessage &&
                <MessageBar messageBarType={MessageBarType.warning}>
                    {this.state.warningMessage}
                </MessageBar>
            }
            <StatefulSplitter
                statefulSettingsPath="Git.Explorer.BlameSplitter"
                left={
                    isFixedPaneVisible &&
                    <BlameList
                        repositoryContext={this.props.repositoryContext}
                        path={this.props.displayItem && this.props.displayItem.serverItem}
                        blocks={this.state.blocks}
                        firstVersion={this.getFirstVersion()}
                        versionsMap={this.annotationEngine ? this.annotationEngine.getVersionMap() : {}}
                        getVersion={this.getVersionForLineNumber}
                        currentLineNumber={this.state.lineNumber}
                        onCommitClick={this.props.onCommitClick}
                        onScroll={this.onBlameScrollChanged}
                        onViewBlamePrior={this.props.onChangeVersion && this.viewBlamePrior}
                        scrollTop={this.state.blameScrollTop}
                        lineHeight={this.state.lineHeight}
                        firstLineTop={this.state.firstLineTop}
                    />
                }
                isFixedPaneVisible={isFixedPaneVisible}
                right={
                    <EditableFileViewer
                        {...this.props}
                        preserveLineHeight={isFixedPaneVisible}
                        ref={requestScroll}
                        scrollTop={this.state.fileScrollTop}
                        onSelectionChanged={this.onFileViewerSelectionChanged}
                        onScrollChanged={this.onFileViewerScrollChanged}
                        />
                }
                enableToggleButton={false}
                />
            </div>;
    }

    private hasBlocks(): boolean {
        return this.state.blocks && this.state.blocks.length > 0;
    }

    private getFirstVersion(): string {
        const firstEntry = last(this.annotationEngine && this.annotationEngine.getHistoryEntries());
        return firstEntry && firstEntry.changeList.version;
    }

    private getVersionForLineNumber = (lineNumber: number): string => {
        return lineNumber &&
            this.annotationEngine &&
            this.annotationEngine.getVersionForLineNumber(lineNumber);
    }

    private createAnnotationEngine(props: AnnotatedFileViewerProps): void {
        const item = props.displayItem;
        if (!props.isAnnotate || !props.isVisible || !item || this.annotationEngine) {
            return;
        }

        this.annotationEngine =
            this.props.repositoryContext.getRepositoryType() === RepositoryType.Git
            ? new GitAnnotationEngine(this.props.repositoryContext as GitRepositoryContext, item.serverItem, item.version)
            : new TfsAnnotationEngine(this.props.repositoryContext as TfvcRepositoryContext, item.serverItem, item.version);

        this.annotationEngine.addProgressListener(this.refreshBlocks);
        this.annotationEngine.addErrorCallback(this.showError);
        this.annotationEngine.start();
    }

    private destroyEngine() {
        if (this.annotationEngine) {
            this.annotationEngine.cancel();
            this.annotationEngine = undefined;
        }
    }

    private showError = (error: Error) => {
        this.setState({
            warningMessage: error.message,
            // Hide loading indicator if no blocks were retrieved yet.
            blocks: this.state.blocks || [],
        });
    }

    private refreshBlocks = (blocks: AnnotationBlock[], versionsMap: VersionMap, complete: boolean) => {
        if (blocks.length || complete) {
            const warningMessage =
                this.annotationEngine.hasUnprocessedHistory()
                ? VCResources.AnnotateUnprocessedHistoryWarningFormat
                : this.annotationEngine.hasMoreHistoryAvailable()
                ? format(VCResources.AnnotateMaxHistoryWarningFormat, this.annotationEngine.getHistoryEntries().length)
                : undefined;

            this.setState({
                blocks: fillGaps(blocks, this.props.linesCount),
                warningMessage,
            } as AnnotatedFileViewerState);
        }
    }

    private onFileViewerSelectionChanged = (selection: FileViewerSelection): void => {
        this.setState({
            lineNumber: selection.startLineNumber,
        } as AnnotatedFileViewerState);
    }

    private onFileViewerScrollChanged = (position: FileViewerScrollPosition): void => {
        this.setState(updateScrollTop(position.scrollTop, "fileScrollTop", position.lineHeight, position.firstLineTop));
    }

    private onBlameScrollChanged = (scrollTop: number): void => {
        this.setState(updateScrollTop(scrollTop, "blameScrollTop"));
    }

    private viewBlamePrior = (changeList: ChangeList, line: number) => {
        if (this.props.onChangeVersion && this.annotationEngine) {
            const previousEntry = getPreviousHistoryEntry(this.annotationEngine.getHistoryEntries(), changeList.version);
            if (previousEntry) {
                this.props.onChangeVersion(previousEntry.changeList.version, line);
            }
        }
    }
}

function getPreviousHistoryEntry(history: HistoryEntry[], version: string): HistoryEntry {
    for (let i = 0; i < history.length - 1; i++) {
        if (history[i].changeList.version === version) {
            return history[i + 1];
        }
    }
}

function requestScroll(fileViewer: EditableFileViewer) {
    if (fileViewer) {
        fileViewer.raiseScrollChanged();
    }
}

/**
 * Adds extra blocks with unknown version for the lines not covered by the provided blocks.
 */
export function fillGaps(blocks: AnnotationBlock[], linesCount: number): AnnotationBlock[] {
    const result: AnnotationBlock[] = [];
    let expectedNextLine = 1;
    for (const block of blocks) {
        const gapSize = block.startLine - expectedNextLine;
        if (gapSize > 0) {
            result.push({
                startLine: expectedNextLine,
                lineCount: gapSize,
                version: "unknown",
            });
        }

        result.push(block);
        expectedNextLine = block.startLine + block.lineCount;
    }

    if (expectedNextLine <= linesCount) {
        result.push(createFinalGap(expectedNextLine, linesCount));
    }

    return result;
}

function createFinalGap(nextLine: number, linesCount: number): AnnotationBlock {
    return {
        startLine: nextLine,
        lineCount: linesCount - nextLine + 1,
        version: "unknown-cut",
    };
}

export function updateScrollTop(
    scrollTop: number,
    changedPropertyName: keyof AnnotatedFileViewerState,
    lineHeight?: number,
    firstLineTop?: number,
    now: number = Date.now(),
) {
    const targetRequestedPropertyName: keyof AnnotatedFileViewerState =
        changedPropertyName === "blameScrollTop" ? "fileScrollTop" : "blameScrollTop";

    return (state: AnnotatedFileViewerState): AnnotatedFileViewerState => {
        const requestedScrollTop = state[changedPropertyName] as number;

        if (requestedScrollTop === undefined || hasExpiredScrollRequest(state, now)) {
            return {
                [targetRequestedPropertyName]: scrollTop,
                [changedPropertyName]: undefined,
                requestedScrollTime: now,
                lineHeight: lineHeight || state.lineHeight,
                firstLineTop: firstLineTop !== undefined ? firstLineTop : state.firstLineTop,
            } as Partial<AnnotatedFileViewerState> as AnnotatedFileViewerState;
        } else if (areSimilar(scrollTop, requestedScrollTop)) {
            return {
                [changedPropertyName]: undefined,
                requestedScrollTime: undefined,
            } as AnnotatedFileViewerState;
        }
    };
}

function hasExpiredScrollRequest(state: AnnotatedFileViewerState, now: number) {
    if (!state.blocks) {
        // If blocks are not loaded yet, don't expire: we cannot apply scrollTop before the list is populated.
        return false;
    }

    return now - state.requestedScrollTime > requestScrollExpiracyMilliseconds;
}

function last<T>(array: T[]): T {
    if (array && array.length > 0) {
        return array[array.length - 1];
    }
}
